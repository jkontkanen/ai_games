<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#1f2937"/>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="description" content="A fun cat and mouse game where you pursue cheese and avoid cats!">
    <link rel="manifest" id="manifest">
    
    <title>Cheese Pursuit</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none; /* Disable panning and zooming on touch devices */
        }
        #game-area {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            border-radius: 0.75rem;
            cursor: pointer;
            /* Added a subtle background pattern */
            background-color: #e5e7eb; /* bg-gray-200 */
            background-image: radial-gradient(#9ca3af 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .game-object {
            position: absolute;
            font-size: 2.5rem; /* Increased size for better visibility */
            user-select: none;
            /* Added drop-shadow for a 3D effect that conforms to the emoji shape */
            filter: drop-shadow(4px 4px 3px rgba(0, 0, 0, 0.3));
        }
        .wall {
            position: absolute;
            border-radius: 0.25rem;
            /* Added a brick-like texture */
            background-color: #6b7280; /* bg-gray-500 */
            background-image: linear-gradient(45deg, #4b5563 25%, transparent 25%, transparent 50%, #4b5563 50%, #4b5563 75%, transparent 75%, transparent);
            background-size: 15px 15px;
            border: 2px solid #374151;
            /* Added a box-shadow for depth */
            box-shadow: 4px 4px 6px rgba(0, 0, 0, 0.2);
        }
        #touch-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 0.5rem;
            width: 150px;
            height: 150px;
        }
        .touch-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #4b5563; /* bg-gray-700 */
            color: white;
            border-radius: 9999px; /* rounded-full */
            font-size: 1.5rem;
            cursor: pointer;
            user-select: none;
        }
        .touch-btn:active {
            background-color: #374151; /* bg-gray-800 */
        }
        #up { grid-column: 2; grid-row: 1; }
        #left { grid-column: 1; grid-row: 2; }
        #right { grid-column: 3; grid-row: 2; }
        #down { grid-column: 2; grid-row: 3; }
    </style>
</head>
<body class="bg-gray-800 flex flex-col items-center justify-center min-h-screen p-4 pb-24 md:pb-4 text-white">

    <!-- Start Screen -->
    <div id="start-screen" class="fixed inset-0 bg-gray-800 flex flex-col items-center justify-center z-50 text-center p-4">
        <h1 class="text-6xl md:text-8xl font-bold text-yellow-400" style="filter: drop-shadow(4px 4px 3px rgba(0,0,0,0.4));">Cheese Pursuit</h1>
        <button id="start-btn" class="mt-10 bg-yellow-500 hover:bg-yellow-600 text-gray-800 font-bold py-3 px-8 rounded-lg text-2xl shadow-lg transform hover:scale-105 transition-transform duration-200">Start Game</button>
    </div>

    <!-- Main Game Content (initially hidden) -->
    <div id="main-game" class="hidden w-full flex flex-col items-center">
        <div class="w-full max-w-2xl mx-auto text-center mb-4">
            <h1 class="text-4xl font-bold text-yellow-400">Cheese Pursuit</h1>
            <div id="score" class="mt-4 text-2xl font-semibold bg-gray-700 rounded-lg px-4 py-2 inline-block">Score: 0</div>
        </div>

        <!-- Game Area -->
        <div class="w-full max-w-2xl h-96 md:h-[500px] bg-gray-100 rounded-xl shadow-2xl overflow-hidden" id="game-container">
            <div id="game-area">
                <div id="mouse" class="game-object">üê≠</div>
                <div id="cheese" class="game-object">üßÄ</div>
                <!-- Cats will be generated here by JS -->
            </div>
        </div>
        
        <!-- On-screen controls for touch devices -->
        <div id="touch-controls" class="mt-6 md:hidden">
            <div id="up" class="touch-btn">‚ñ≤</div>
            <div id="left" class="touch-btn">‚óÄ</div>
            <div id="right" class="touch-btn">‚ñ∂</div>
            <div id="down" class="touch-btn">‚ñº</div>
        </div>
    </div>

    <!-- Message Box -->
    <div id="message-box" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
        <div class="bg-white text-gray-800 p-8 rounded-lg shadow-xl text-center">
            <h2 id="message-title" class="text-3xl font-bold mb-4">Game Over!</h2>
            <p id="message-text">A predator caught you!</p>
            <button id="restart-btn" class="mt-6 bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg text-lg">Play Again</button>
        </div>
    </div>

    <script>
        // --- PWA Setup ---
        // Dynamically create and link the manifest
        const manifest = {
            "name": "Cheese Pursuit",
            "short_name": "Cheese Pursuit",
            "start_url": ".",
            "display": "standalone",
            "background_color": "#1f2937",
            "theme_color": "#1f2937",
            "description": "A fun cat and mouse game where you pursue cheese and avoid cats!",
            "icons": [{
                "src": "https://placehold.co/192x192/facc15/1f2937?text=CP",
                "sizes": "192x192",
                "type": "image/png"
            }, {
                "src": "https://placehold.co/512x512/facc15/1f2937?text=CP",
                "sizes": "512x512",
                "type": "image/png"
            }]
        };
        const manifestBlob = new Blob([JSON.stringify(manifest)], {type: 'application/json'});
        const manifestURL = URL.createObjectURL(manifestBlob);
        document.querySelector('#manifest').setAttribute('href', manifestURL);

        // Register the service worker for offline capabilities
        if ('serviceWorker' in navigator) {
            const swContent = `
                const CACHE_NAME = 'cheese-pursuit-v1';
                const assetsToCache = [
                    '/',
                    'https://cdn.tailwindcss.com',
                    'https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js',
                    'https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap'
                ];

                self.addEventListener('install', event => {
                    event.waitUntil(
                        caches.open(CACHE_NAME).then(cache => {
                            return cache.addAll(assetsToCache);
                        })
                    );
                });

                self.addEventListener('fetch', event => {
                    event.respondWith(
                        caches.match(event.request).then(response => {
                            return response || fetch(event.request);
                        })
                    );
                });
            `;
            const swBlob = new Blob([swContent], {type: 'application/javascript'});
            const swURL = URL.createObjectURL(swBlob);
            navigator.serviceWorker.register(swURL)
                .then(() => console.log('Service Worker registered successfully.'))
                .catch(error => console.log('Service Worker registration failed:', error));
        }


        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const startScreen = document.getElementById('start-screen');
            const startBtn = document.getElementById('start-btn');
            const mainGame = document.getElementById('main-game');
            const gameArea = document.getElementById('game-area');
            const mouse = document.getElementById('mouse');
            const cheese = document.getElementById('cheese');
            const scoreDisplay = document.getElementById('score');
            const messageBox = document.getElementById('message-box');
            const messageTitle = document.getElementById('message-title');
            const messageText = document.getElementById('message-text');
            const restartBtn = document.getElementById('restart-btn');

            // Game State
            let score = 0;
            let mouseX, mouseY;
            let cats = [];
            let gameOver = false;
            let animationFrameId;
            let audioStarted = false;

            // Game Parameters
            const mouseSpeed = 3; 
            const catSpeed = 0.7;
            const objectSize = 40;
            const wallCollisionPadding = 5;

            // Input state tracker
            const keysPressed = {
                ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
            };

            // Wall Definitions
            const wallDefinitions = [
                { x: 20, y: 0, width: 5, height: 40 }, { x: 20, y: 60, width: 5, height: 40 },
                { x: 75, y: 0, width: 5, height: 40 }, { x: 75, y: 60, width: 5, height: 40 },
                { x: 40, y: 25, width: 20, height: 5 }, { x: 40, y: 70, width: 20, height: 5 },
            ];
            let walls = [];
            
            // --- Sound Effects ---
            const synth = new Tone.Synth().toDestination();
            const noise = new Tone.NoiseSynth().toDestination();

            function playMeow() {
                if (!audioStarted) return;
                synth.triggerAttackRelease("A4", "8n", Tone.now());
                synth.triggerAttackRelease("C5", "8n", Tone.now() + 0.1);
            }

            function playRoar() {
                if (!audioStarted) return;
                synth.triggerAttackRelease("G2", "4n");
            }

            function playSqueak() {
                if (!audioStarted) return;
                noise.triggerAttackRelease("8n");
            }

            function startAudioContext() {
                if (!audioStarted && Tone.context.state !== 'running') {
                    Tone.start();
                    audioStarted = true;
                }
            }
            
            // --- Game Setup ---
            function initializeGame() {
                gameOver = false;
                score = 0;
                
                messageBox.classList.add('hidden');
                
                gameArea.querySelectorAll('.cat, .wall').forEach(el => el.remove());
                cats = [];
                walls = [];

                createWalls();
                
                mouseX = gameArea.offsetWidth / 2;
                mouseY = gameArea.offsetHeight / 2;
                updateMousePosition();

                addCat(); 
                updateScore();

                placeCheeseRandomly();
                
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                gameLoop();
            }

            // --- Cat Management ---
            function addCat() {
                playMeow();
                const catEl = document.createElement('div');
                catEl.classList.add('game-object', 'cat');
                catEl.textContent = 'üê±';
                gameArea.appendChild(catEl);

                const corners = [
                    { x: objectSize, y: objectSize },
                    { x: gameArea.offsetWidth - objectSize, y: objectSize },
                    { x: objectSize, y: gameArea.offsetHeight - objectSize },
                    { x: gameArea.offsetWidth - objectSize, y: gameArea.offsetHeight - objectSize }
                ];

                let bestCorner = null;
                let maxDistance = -1;

                corners.forEach(corner => {
                    const dx = corner.x - mouseX;
                    const dy = corner.y - mouseY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > maxDistance) {
                        maxDistance = distance;
                        bestCorner = corner;
                    }
                });

                const newCat = {
                    x: bestCorner.x, y: bestCorner.y, el: catEl,
                    isSuper: false, speed: catSpeed,
                };
                cats.push(newCat);
                updateCatPosition(newCat);
            }

            // --- Wall Creation ---
            function createWalls() {
                const gameWidth = gameArea.offsetWidth;
                const gameHeight = gameArea.offsetHeight;
                wallDefinitions.forEach(def => {
                    const wallEl = document.createElement('div');
                    wallEl.classList.add('wall');
                    wallEl.style.left = `${(def.x / 100) * gameWidth}px`;
                    wallEl.style.top = `${(def.y / 100) * gameHeight}px`;
                    wallEl.style.width = `${(def.width / 100) * gameWidth}px`;
                    wallEl.style.height = `${(def.height / 100) * gameHeight}px`;
                    gameArea.appendChild(wallEl);
                    walls.push({ el: wallEl });
                });
            }
            
            // --- Core Functions ---
            function updateMousePosition() {
                mouse.style.left = `${mouseX - objectSize / 2}px`;
                mouse.style.top = `${mouseY - objectSize / 2}px`;
            }
            
            function updateCatPosition(cat) {
                cat.el.style.left = `${cat.x - objectSize / 2}px`;
                cat.el.style.top = `${cat.y - objectSize / 2}px`;
            }

            function updateScore() {
                scoreDisplay.textContent = `Score: ${score}`;
                const expectedCats = Math.floor(score / 10) + 1;
                if (cats.length < expectedCats) {
                    addCat();
                }
            }

            function placeCheeseRandomly() {
                let randomX, randomY, validPosition;
                const maxX = gameArea.offsetWidth - objectSize;
                const maxY = gameArea.offsetHeight - objectSize;
                do {
                    randomX = Math.floor(Math.random() * maxX) + objectSize / 2;
                    randomY = Math.floor(Math.random() * maxY) + objectSize / 2;
                    const cheeseRect = { 
                        left: randomX - objectSize / 2, top: randomY - objectSize / 2, 
                        right: randomX + objectSize / 2, bottom: randomY + objectSize / 2 
                    };
                    validPosition = !isCollidingWithWall(cheeseRect);
                } while (!validPosition);
                cheese.style.left = `${randomX - objectSize / 2}px`;
                cheese.style.top = `${randomY - objectSize / 2}px`;
            }
            
            // --- Collision Detection ---
            function isColliding(rect1, rect2) {
                return (
                    rect1.left < rect2.right && rect1.right > rect2.left &&
                    rect1.top < rect2.bottom && rect1.bottom > rect2.top
                );
            }

            function isCollidingWithWall(rect) {
                const smallerRect = {
                    left: rect.left + wallCollisionPadding, right: rect.right - wallCollisionPadding,
                    top: rect.top + wallCollisionPadding, bottom: rect.bottom - wallCollisionPadding,
                };
                for (const wall of walls) {
                    const wallRect = wall.el.getBoundingClientRect();
                    const gameRect = gameArea.getBoundingClientRect();
                    const relativeWallRect = {
                        left: wallRect.left - gameRect.left, right: wallRect.right - gameRect.left,
                        top: wallRect.top - gameRect.top, bottom: wallRect.bottom - gameRect.top,
                    };
                    if (isColliding(smallerRect, relativeWallRect)) return true;
                }
                return false;
            }

            function checkCheeseCollision() {
                if (isColliding(mouse.getBoundingClientRect(), cheese.getBoundingClientRect())) {
                    score++;
                    updateScore();
                    placeCheeseRandomly();
                }
            }
            
            function checkCatCollision() {
                const mouseRect = mouse.getBoundingClientRect();
                const collisionPadding = 10; 
                const smallerMouseRect = {
                    left: mouseRect.left + collisionPadding, right: mouseRect.right - collisionPadding,
                    top: mouseRect.top + collisionPadding, bottom: mouseRect.bottom - collisionPadding
                };
                for (const cat of cats) {
                    const catRect = cat.el.getBoundingClientRect();
                    const smallerCatRect = {
                        left: catRect.left + collisionPadding, right: catRect.right - collisionPadding,
                        top: catRect.top + collisionPadding, bottom: catRect.bottom - collisionPadding
                    };
                    if (isColliding(smallerMouseRect, smallerCatRect)) {
                        endGame(cat.isSuper);
                        return;
                    }
                }
            }

            // --- Game Logic ---
            function handlePlayerInput() {
                if (gameOver) return;
                let dx = 0, dy = 0;
                if (keysPressed.ArrowUp) dy = -1;
                if (keysPressed.ArrowDown) dy = 1;
                if (keysPressed.ArrowLeft) dx = -1;
                if (keysPressed.ArrowRight) dx = 1;
                if (dx === 0 && dy === 0) return;

                let nextX = mouseX + dx * mouseSpeed;
                let nextY = mouseY + dy * mouseSpeed;
                nextX = Math.max(objectSize / 2, Math.min(nextX, gameArea.offsetWidth - objectSize / 2));
                nextY = Math.max(objectSize / 2, Math.min(nextY, gameArea.offsetHeight - objectSize / 2));
                const nextRect = {
                    left: nextX - objectSize / 2, top: nextY - objectSize / 2,
                    right: nextX + objectSize / 2, bottom: nextY + objectSize / 2
                };
                if (!isCollidingWithWall(nextRect)) {
                    mouseX = nextX;
                    mouseY = nextY;
                }
                updateMousePosition();
            }

            function moveCats() {
                if (gameOver) return;
                cats.forEach(cat => {
                    const dx = mouseX - cat.x;
                    const dy = mouseY - cat.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > 1) {
                        let nextX = cat.x + (dx / distance) * cat.speed;
                        let nextY = cat.y + (dy / distance) * cat.speed;
                        const nextRect = {
                            left: nextX - objectSize / 2, top: nextY - objectSize / 2,
                            right: nextX + objectSize / 2, bottom: nextY + objectSize / 2
                        };
                        if (!isCollidingWithWall(nextRect)) {
                            cat.x = nextX;
                            cat.y = nextY;
                            updateCatPosition(cat);
                        }
                    }
                });
            }
            
            function fuseCats() {
                if (gameOver) return;
                for (let i = 0; i < cats.length; i++) {
                    for (let j = i + 1; j < cats.length; j++) {
                        const cat1 = cats[i];
                        const cat2 = cats[j];
                        
                        if (cat1.isSuper || cat2.isSuper) continue;

                        const rect1 = cat1.el.getBoundingClientRect();
                        const rect2 = cat2.el.getBoundingClientRect();

                        if (isColliding(rect1, rect2)) {
                            playRoar();
                            cat1.isSuper = true;
                            cat1.speed = catSpeed * 2;
                            cat1.el.textContent = 'üêØ';

                            cat2.el.remove();
                            cats.splice(j, 1);
                            j--;
                        }
                    }
                }
            }

            function endGame(caughtBySuperCat) {
                playSqueak();
                gameOver = true;
                cancelAnimationFrame(animationFrameId);
                messageTitle.textContent = "Game Over!";
                const predator = caughtBySuperCat ? "supercat" : "cat";
                messageText.textContent = `The ${predator} caught you! Your final score is ${score}.`;
                messageBox.classList.remove('hidden');
            }

            function gameLoop() {
                if (gameOver) return;
                handlePlayerInput();
                moveCats();
                fuseCats();
                checkCheeseCollision();
                checkCatCollision();
                animationFrameId = requestAnimationFrame(gameLoop);
            }

            // --- Event Listeners ---
            startBtn.addEventListener('click', () => {
                startScreen.classList.add('hidden');
                mainGame.classList.remove('hidden');
                startAudioContext();
                initializeGame();
            });

            document.addEventListener('keydown', (e) => {
                if (keysPressed.hasOwnProperty(e.key)) { e.preventDefault(); keysPressed[e.key] = true; }
            });
            document.addEventListener('keyup', (e) => {
                if (keysPressed.hasOwnProperty(e.key)) { e.preventDefault(); keysPressed[e.key] = false; }
            });
            const touchMap = { 'up': 'ArrowUp', 'down': 'ArrowDown', 'left': 'ArrowLeft', 'right': 'ArrowRight' };
            Object.entries(touchMap).forEach(([id, key]) => {
                const button = document.getElementById(id);
                const press = (e) => { e.preventDefault(); keysPressed[key] = true; };
                const release = (e) => { e.preventDefault(); keysPressed[key] = false; };
                button.addEventListener('touchstart', press);
                button.addEventListener('touchend', release);
                button.addEventListener('touchcancel', release);
            });
            restartBtn.addEventListener('click', initializeGame);
            window.addEventListener('resize', () => {
                // Only re-initialize if the game hasn't started yet.
                // This prevents losing progress if the screen is rotated mid-game.
                if (mainGame.classList.contains('hidden')) {
                    // No need to call initializeGame here, as the layout will adjust.
                    // If we were to call it, it would create walls and cats before the game starts.
                }
            });

        });
    </script>
</body>
</html>
