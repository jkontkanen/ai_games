<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#1f2937"/>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="description" content="A fun cat and mouse game where you pursue cheese and avoid cats!">
    <link rel="manifest" id="manifest">
    
    <title>Cheese Pursuit</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none; /* Disable panning and zooming on touch devices */
        }
        #game-area {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            border-radius: 0.75rem;
            cursor: pointer;
            /* Added a subtle background pattern */
            background-color: #e5e7eb; /* bg-gray-200 */
            background-image: radial-gradient(#9ca3af 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .game-object {
            position: absolute;
            /* Font size is now set dynamically in JavaScript */
            user-select: none;
            /* Added drop-shadow for a 3D effect that conforms to the emoji shape */
            filter: drop-shadow(4px 4px 3px rgba(0, 0, 0, 0.3));
            /* Fix for Safari rendering bug with filter + transform */
            transform: translateZ(0);
        }
        .wall {
            position: absolute;
            border-radius: 0.25rem;
            /* Added a brick-like texture */
            background-color: #6b7280; /* bg-gray-500 */
            background-image: linear-gradient(45deg, #4b5563 25%, transparent 25%, transparent 50%, #4b5563 50%, #4b5563 75%, transparent 75%, transparent);
            background-size: 15px 15px;
            border: 2px solid #374151;
            /* Added a box-shadow for depth */
            box-shadow: 4px 4px 6px rgba(0, 0, 0, 0.2);
        }
        #touch-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 0; /* Removed gap for seamless sliding */
            width: 180px; /* Increased size */
            height: 180px; /* Increased size */
        }
        .touch-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #4b5563; /* bg-gray-700 */
            color: white;
            border-radius: 9999px; /* rounded-full */
            font-size: 2rem; /* Increased arrow size */
            cursor: pointer;
            user-select: none;
            transition: background-color 0.1s ease-in-out;
        }
        .touch-btn.active {
            background-color: #374151; /* bg-gray-800 */
        }
        #up { grid-column: 2; grid-row: 1; }
        #left { grid-column: 1; grid-row: 2; }
        #right { grid-column: 3; grid-row: 2; }
        #down { grid-column: 2; grid-row: 3; }
    </style>
</head>
<body class="bg-gray-800 flex flex-col items-center justify-center min-h-screen p-4 pb-24 md:pb-4 text-white">

    <!-- Start Screen -->
    <div id="start-screen" class="fixed inset-0 bg-gray-800 flex flex-col items-center justify-center z-50 text-center p-4">
        <h1 class="text-6xl md:text-8xl font-bold text-yellow-400" style="filter: drop-shadow(4px 4px 3px rgba(0,0,0,0.4));">Cheese Pursuit</h1>
        <button id="start-btn" class="mt-10 bg-yellow-500 hover:bg-yellow-600 text-gray-800 font-bold py-3 px-8 rounded-lg text-2xl shadow-lg transform hover:scale-105 transition-transform duration-200">Start Game</button>
        <div class="absolute bottom-2 right-2 text-xs text-gray-500">v1.1</div>
    </div>

    <!-- Main Game Content (initially hidden) -->
    <div id="main-game" class="hidden w-full flex flex-col items-center">
        <div class="w-full max-w-2xl mx-auto text-center mb-4">
            <h1 class="text-4xl font-bold text-yellow-400">Cheese Pursuit</h1>
            <div id="score" class="mt-4 text-2xl font-semibold bg-gray-700 rounded-lg px-4 py-2 inline-block">Score: 0</div>
        </div>

        <!-- Game Area -->
        <div class="w-full max-w-2xl h-96 md:h-[500px] bg-gray-100 rounded-xl shadow-2xl overflow-hidden" id="game-container">
            <div id="game-area">
                <div id="mouse" class="game-object">üê≠</div>
                <div id="cheese" class="game-object">üßÄ</div>
                <!-- Cats will be generated here by JS -->
            </div>
        </div>
        
        <!-- On-screen controls for touch devices -->
        <div id="touch-controls" class="mt-6 md:hidden">
            <div id="up" class="touch-btn">‚ñ≤</div>
            <div id="left" class="touch-btn">‚óÄ</div>
            <div id="right" class="touch-btn">‚ñ∂</div>
            <div id="down" class="touch-btn">‚ñº</div>
        </div>
    </div>

    <!-- Message Box -->
    <div id="message-box" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
        <div class="bg-white text-gray-800 p-8 rounded-lg shadow-xl text-center">
            <h2 id="message-title" class="text-3xl font-bold mb-4">Game Over!</h2>
            <p id="message-text">A predator caught you!</p>
            <button id="restart-btn" class="mt-6 bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg text-lg">Play Again</button>
        </div>
    </div>

    <script>
        // --- PWA Setup ---
        const manifest = {
            "name": "Cheese Pursuit", "short_name": "Cheese Pursuit", "start_url": ".",
            "display": "standalone", "background_color": "#1f2937", "theme_color": "#1f2937",
            "description": "A fun cat and mouse game where you pursue cheese and avoid cats!",
            "icons": [{"src": "https://placehold.co/192x192/facc15/1f2937?text=CP", "sizes": "192x192", "type": "image/png"},
                      {"src": "https://placehold.co/512x512/facc15/1f2937?text=CP", "sizes": "512x512", "type": "image/png"}]
        };
        const manifestBlob = new Blob([JSON.stringify(manifest)], {type: 'application/json'});
        const manifestURL = URL.createObjectURL(manifestBlob);
        document.querySelector('#manifest').setAttribute('href', manifestURL);

        if ('serviceWorker' in navigator) {
            const swContent = `
                const CACHE_NAME = 'cheese-pursuit-v1';
                const assetsToCache = ['/', 'https://cdn.tailwindcss.com', 'https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js', 'https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap'];
                self.addEventListener('install', e => e.waitUntil(caches.open(CACHE_NAME).then(c => c.addAll(assetsToCache))));
                self.addEventListener('fetch', e => e.respondWith(caches.match(e.request).then(r => r || fetch(e.request))));
            `;
            const swBlob = new Blob([swContent], {type: 'application/javascript'});
            const swURL = URL.createObjectURL(swBlob);
            navigator.serviceWorker.register(swURL).catch(err => console.log('SW registration failed:', err));
        }

        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const startScreen = document.getElementById('start-screen');
            const startBtn = document.getElementById('start-btn');
            const mainGame = document.getElementById('main-game');
            const gameArea = document.getElementById('game-area');
            const mouse = document.getElementById('mouse');
            const cheese = document.getElementById('cheese');
            const scoreDisplay = document.getElementById('score');
            const messageBox = document.getElementById('message-box');
            const restartBtn = document.getElementById('restart-btn');

            // Game State
            let score = 0, mouseX, mouseY, cats = [], gameOver = false, animationFrameId, audioStarted = false;
            let lastTime = 0;
            let isMouseDown = false;

            // Game Parameters (pixels per second)
            const mouseSpeed = 180; 
            const catSpeed = 45;
            let objectSize;
            const wallCollisionPadding = 5;

            // Input state tracker
            const keysPressed = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

            // Wall Definitions
            const wallDefinitions = [
                { x: 20, y: 0, width: 5, height: 40 }, { x: 20, y: 60, width: 5, height: 40 },
                { x: 75, y: 0, width: 5, height: 40 }, { x: 75, y: 60, width: 5, height: 40 },
                { x: 40, y: 25, width: 20, height: 5 }, { x: 40, y: 70, width: 20, height: 5 },
            ];
            let walls = [];
            
            // --- Sound Effects ---
            const synth = new Tone.Synth().toDestination();
            const noise = new Tone.NoiseSynth().toDestination();
            function playMeow() { if (audioStarted) { synth.triggerAttackRelease("A4", "8n", Tone.now()); synth.triggerAttackRelease("C5", "8n", Tone.now() + 0.1); } }
            function playRoar() { if (audioStarted) synth.triggerAttackRelease("G2", "4n"); }
            function playLionRoar() { if (audioStarted) synth.triggerAttackRelease("G1", "2n"); }
            function playSqueak() { if (audioStarted) noise.triggerAttackRelease("8n"); }
            function startAudioContext() { if (!audioStarted && Tone.context.state !== 'running') { Tone.start(); audioStarted = true; } }
            
            // --- Game Setup ---
            function initializeGame() {
                objectSize = Math.min(gameArea.offsetWidth, gameArea.offsetHeight) * 0.06;
                document.querySelectorAll('.game-object').forEach(el => el.style.fontSize = `${objectSize}px`);

                gameOver = false;
                score = 0;
                lastTime = 0; // Reset time for delta time calculation
                
                messageBox.classList.add('hidden');
                
                gameArea.querySelectorAll('.cat, .wall').forEach(el => el.remove());
                cats = [];
                walls = [];

                createWalls();
                
                mouseX = gameArea.offsetWidth / 2;
                mouseY = gameArea.offsetHeight / 2;
                updateMousePosition();

                addCat(); 
                updateScore();
                placeCheeseRandomly();
                
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = requestAnimationFrame(gameLoop);
            }

            // --- Cat Management ---
            function addCat() {
                playMeow();
                const catEl = document.createElement('div');
                catEl.classList.add('game-object', 'cat');
                catEl.textContent = 'üê±';
                catEl.style.fontSize = `${objectSize}px`;
                gameArea.appendChild(catEl);

                const corners = [
                    { x: objectSize, y: objectSize }, { x: gameArea.offsetWidth - objectSize, y: objectSize },
                    { x: objectSize, y: gameArea.offsetHeight - objectSize }, { x: gameArea.offsetWidth - objectSize, y: gameArea.offsetHeight - objectSize }
                ];
                let bestCorner = null, maxDistance = -1;
                corners.forEach(corner => {
                    const dist = Math.hypot(corner.x - mouseX, corner.y - mouseY);
                    if (dist > maxDistance) { maxDistance = dist; bestCorner = corner; }
                });

                const newCat = { x: bestCorner.x, y: bestCorner.y, el: catEl, level: 1, speed: catSpeed };
                cats.push(newCat);
                updateCatPosition(newCat);
            }

            // --- Wall Creation ---
            function createWalls() {
                const gameWidth = gameArea.offsetWidth, gameHeight = gameArea.offsetHeight;
                wallDefinitions.forEach(def => {
                    const wallEl = document.createElement('div');
                    wallEl.classList.add('wall');
                    wallEl.style.left = `${(def.x / 100) * gameWidth}px`;
                    wallEl.style.top = `${(def.y / 100) * gameHeight}px`;
                    wallEl.style.width = `${(def.width / 100) * gameWidth}px`;
                    wallEl.style.height = `${(def.height / 100) * gameHeight}px`;
                    gameArea.appendChild(wallEl);
                    walls.push({ el: wallEl });
                });
            }
            
            // --- Core Functions ---
            function updateMousePosition() { mouse.style.left = `${mouseX - objectSize / 2}px`; mouse.style.top = `${mouseY - objectSize / 2}px`; }
            function updateCatPosition(cat) { cat.el.style.left = `${cat.x - objectSize / 2}px`; cat.el.style.top = `${cat.y - objectSize / 2}px`; }
            function updateScore() {
                scoreDisplay.textContent = `Score: ${score}`;
                if (cats.length < Math.floor(score / 10) + 1) addCat();
            }

            function placeCheeseRandomly() {
                let randomX, randomY, validPosition;
                const maxX = gameArea.offsetWidth - objectSize, maxY = gameArea.offsetHeight - objectSize;
                do {
                    randomX = Math.random() * maxX + objectSize / 2;
                    randomY = Math.random() * maxY + objectSize / 2;
                    const cheeseRect = { left: randomX - objectSize / 2, top: randomY - objectSize / 2, right: randomX + objectSize / 2, bottom: randomY + objectSize / 2 };
                    validPosition = !isCollidingWithWall(cheeseRect);
                } while (!validPosition);
                cheese.style.left = `${randomX - objectSize / 2}px`;
                cheese.style.top = `${randomY - objectSize / 2}px`;
            }
            
            // --- Collision Detection ---
            function isColliding(r1, r2) { return !(r2.left > r1.right || r2.right < r1.left || r2.top > r1.bottom || r2.bottom < r1.top); }
            function isCollidingWithWall(rect) {
                const smallerRect = { left: rect.left + wallCollisionPadding, right: rect.right - wallCollisionPadding, top: rect.top + wallCollisionPadding, bottom: rect.bottom - wallCollisionPadding };
                for (const wall of walls) {
                    const wallRect = wall.el.getBoundingClientRect(), gameRect = gameArea.getBoundingClientRect();
                    const relWallRect = { left: wallRect.left - gameRect.left, right: wallRect.right - gameRect.left, top: wallRect.top - gameRect.top, bottom: wallRect.bottom - gameRect.top };
                    if (isColliding(smallerRect, relWallRect)) return true;
                }
                return false;
            }
            function checkCheeseCollision() { if (isColliding(mouse.getBoundingClientRect(), cheese.getBoundingClientRect())) { score++; updateScore(); placeCheeseRandomly(); } }
            function checkCatCollision() {
                const mouseRect = mouse.getBoundingClientRect(), padding = objectSize * 0.25;
                const smallerMouseRect = { left: mouseRect.left + padding, right: mouseRect.right - padding, top: mouseRect.top + padding, bottom: mouseRect.bottom - padding };
                for (const cat of cats) {
                    const catRect = cat.el.getBoundingClientRect();
                    const smallerCatRect = { left: catRect.left + padding, right: catRect.right - padding, top: catRect.top + padding, bottom: catRect.bottom - padding };
                    if (isColliding(smallerMouseRect, smallerCatRect)) { endGame(cat.level); return; }
                }
            }

            // --- Game Logic ---
            function handlePlayerInput(deltaTime) {
                if (gameOver) return;
                let dx = 0, dy = 0;
                if (keysPressed.ArrowUp) dy = -1; if (keysPressed.ArrowDown) dy = 1;
                if (keysPressed.ArrowLeft) dx = -1; if (keysPressed.ArrowRight) dx = 1;
                if (dx === 0 && dy === 0) return;

                let nextX = mouseX + dx * mouseSpeed * deltaTime;
                let nextY = mouseY + dy * mouseSpeed * deltaTime;
                nextX = Math.max(objectSize / 2, Math.min(nextX, gameArea.offsetWidth - objectSize / 2));
                nextY = Math.max(objectSize / 2, Math.min(nextY, gameArea.offsetHeight - objectSize / 2));
                const nextRect = { left: nextX - objectSize / 2, top: nextY - objectSize / 2, right: nextX + objectSize / 2, bottom: nextY + objectSize / 2 };
                if (!isCollidingWithWall(nextRect)) { mouseX = nextX; mouseY = nextY; }
                updateMousePosition();
            }

            function moveCats(deltaTime) {
                if (gameOver) return;
                cats.forEach(cat => {
                    const dist = Math.hypot(mouseX - cat.x, mouseY - cat.y);
                    if (dist > 1) {
                        const dx = (mouseX - cat.x) / dist, dy = (mouseY - cat.y) / dist;
                        let nextX = cat.x + dx * cat.speed * deltaTime;
                        let nextY = cat.y + dy * cat.speed * deltaTime;
                        const nextRect = { left: nextX - objectSize / 2, top: nextY - objectSize / 2, right: nextX + objectSize / 2, bottom: nextY + objectSize / 2 };
                        if (!isCollidingWithWall(nextRect)) { cat.x = nextX; cat.y = nextY; updateCatPosition(cat); }
                    }
                });
            }
            
            function fuseCats() {
                if (gameOver) return;
                for (let i = 0; i < cats.length; i++) {
                    for (let j = i + 1; j < cats.length; j++) {
                        const c1 = cats[i], c2 = cats[j];
                        
                        if (c1.level !== c2.level) continue; // Can only fuse with same level

                        if (isColliding(c1.el.getBoundingClientRect(), c2.el.getBoundingClientRect())) {
                            if (c1.level === 1) { // Cat + Cat -> Tiger
                                playRoar();
                                c1.level = 2;
                                c1.speed = catSpeed * 2;
                                c1.el.textContent = 'üêØ';
                            } else if (c1.level === 2) { // Tiger + Tiger -> Lion
                                playLionRoar();
                                c1.level = 3;
                                c1.speed = (catSpeed * 2) * 1.5; // 50% faster than tiger
                                c1.el.textContent = 'ü¶Å';
                            }
                            
                            c2.el.remove();
                            cats.splice(j, 1);
                            j--;
                        }
                    }
                }
            }

            function endGame(predatorLevel) {
                playSqueak();
                gameOver = true;
                cancelAnimationFrame(animationFrameId);
                const messageTitle = document.getElementById('message-title');
                const messageText = document.getElementById('message-text');
                messageTitle.textContent = "Game Over!";
                let predator;
                if (predatorLevel === 3) predator = "lion";
                else if (predatorLevel === 2) predator = "supercat";
                else predator = "cat";
                messageText.textContent = `The ${predator} caught you! Your final score is ${score}.`;
                messageBox.classList.remove('hidden');
            }

            function gameLoop(currentTime) {
                if (gameOver) return;
                if (!lastTime) lastTime = currentTime;
                const deltaTime = (currentTime - lastTime) / 1000; // Time in seconds
                lastTime = currentTime;

                handlePlayerInput(deltaTime);
                moveCats(deltaTime);
                fuseCats();
                checkCheeseCollision();
                checkCatCollision();
                animationFrameId = requestAnimationFrame(gameLoop);
            }

            // --- Event Listeners ---
            startBtn.addEventListener('click', () => {
                startScreen.classList.add('hidden');
                mainGame.classList.remove('hidden');
                startAudioContext();
                initializeGame();
            });
            document.addEventListener('keydown', e => { if (keysPressed.hasOwnProperty(e.key)) { e.preventDefault(); keysPressed[e.key] = true; } });
            document.addEventListener('keyup', e => { if (keysPressed.hasOwnProperty(e.key)) { e.preventDefault(); keysPressed[e.key] = false; } });
            
            // --- Unified Touch and Mouse Controls ---
            const touchControls = document.getElementById('touch-controls');
            const buttons = {
                up: document.getElementById('up'),
                down: document.getElementById('down'),
                left: document.getElementById('left'),
                right: document.getElementById('right'),
            };

            function updateActiveButtons(event) {
                Object.keys(keysPressed).forEach(key => keysPressed[key] = false);
                Object.values(buttons).forEach(btn => btn.classList.remove('active'));

                const points = event.touches ? Array.from(event.touches) : (isMouseDown ? [event] : []);
                const controlRect = touchControls.getBoundingClientRect();
                const centerX = controlRect.left + controlRect.width / 2;
                const centerY = controlRect.top + controlRect.height / 2;
                const deadZone = controlRect.width * 0.1;

                for (let i = 0; i < points.length; i++) {
                    const point = points[i];
                    const dx = point.clientX - centerX;
                    const dy = point.clientY - centerY;
                    const dist = Math.hypot(dx, dy);

                    if (dist > deadZone) {
                        const angle = Math.atan2(dy, dx) * 180 / Math.PI;

                        if (angle > -135 && angle < -45) {
                            keysPressed.ArrowUp = true;
                            buttons.up.classList.add('active');
                        } else if (angle >= -45 && angle <= 45) {
                            keysPressed.ArrowRight = true;
                            buttons.right.classList.add('active');
                        } else if (angle > 45 && angle < 135) {
                            keysPressed.ArrowDown = true;
                            buttons.down.classList.add('active');
                        } else {
                            keysPressed.ArrowLeft = true;
                            buttons.left.classList.add('active');
                        }
                    }
                }
            }

            function handleInteractionStart(event) {
                event.preventDefault();
                startAudioContext();
                isMouseDown = true;
                updateActiveButtons(event);
            }

            function handleInteractionMove(event) {
                event.preventDefault();
                if (event.touches || isMouseDown) {
                    updateActiveButtons(event);
                }
            }

            function handleInteractionEnd(event) {
                event.preventDefault();
                isMouseDown = false;
                updateActiveButtons(event);
            }
            
            touchControls.addEventListener('touchstart', handleInteractionStart);
            touchControls.addEventListener('touchmove', handleInteractionMove);
            touchControls.addEventListener('touchend', handleInteractionEnd);
            touchControls.addEventListener('touchcancel', handleInteractionEnd);

            touchControls.addEventListener('mousedown', handleInteractionStart);
            touchControls.addEventListener('mousemove', handleInteractionMove);
            document.addEventListener('mouseup', handleInteractionEnd);

            restartBtn.addEventListener('click', initializeGame);
            window.addEventListener('resize', initializeGame);

            // --- Visibility Change Handler ---
            document.addEventListener('visibilitychange', () => {
                // If the page becomes visible again and the game was running, reset it.
                if (document.visibilityState === 'visible' && !mainGame.classList.contains('hidden') && !gameOver) {
                    initializeGame();
                }
            });
        });
    </script>
</body>
</html>

